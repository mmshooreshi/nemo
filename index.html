<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Whisper Chunk Transcriber - Demo Mode</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/js/all.min.js"></script>
    <script src="https://unpkg.com/wavesurfer.js@7.8.6/dist/wavesurfer.min.js"></script>
    <script src="https://unpkg.com/wavesurfer.js@7.8.6/dist/plugins/regions.min.js"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        glass: "rgba(255, 255, 255, 0.05)",
                        glassBorder: "rgba(255, 255, 255, 0.1)",
                        neon: "#3b82f6",
                    },
                    animation: {
                        'pulse-slow': 'pulse 3s cubic-bezier(0.4, 0, 0.6, 1) infinite',
                        'shimmer': 'shimmer 2s linear infinite',
                    },
                    keyframes: {
                        shimmer: {
                            '0%': { transform: 'translateX(-100%)' },
                            '100%': { transform: 'translateX(100%)' }
                        }
                    }
                }
            }
        }
    </script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');

        body {
            font-family: 'Inter', sans-serif;
            background-color: #0f172a;
            color: #e2e8f0;
            background-image: radial-gradient(at 0% 0%, hsla(253, 16%, 7%, 1) 0, transparent 50%),
                radial-gradient(at 50% 0%, hsla(225, 39%, 30%, 1) 0, transparent 50%),
                radial-gradient(at 100% 0%, hsla(339, 49%, 30%, 1) 0, transparent 50%);
            min-height: 100vh;
        }

        .glass-panel {
            background: rgba(30, 41, 59, 0.7);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37);
        }

        .step-line {
            position: absolute;
            left: 24px;
            top: 40px;
            bottom: -20px;
            width: 2px;
            background: #334155;
            z-index: 0;
        }

        .step-item:last-child .step-line {
            display: none;
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #1e293b;
        }

        ::-webkit-scrollbar-thumb {
            background: #475569;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #64748b;
        }

        .recording-pulse {
            animation: recordPulse 1.5s infinite;
        }

        .active-segment {
            background-color: rgba(59, 130, 246, 0.15);
            border-left-color: #3b82f6 !important;
        }

        @keyframes recordPulse {
            0% {
                box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.4);
            }

            70% {
                box-shadow: 0 0 0 10px rgba(239, 68, 68, 0);
            }

            100% {
                box-shadow: 0 0 0 0 rgba(239, 68, 68, 0);
            }
        }

        /* Region Label Styling */
        .region-label {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 10;
            display: flex;
            align-items: center;
            gap: 6px;
            background: rgba(30, 41, 59, 0.9);
            /* Dark Slate */
            color: #94a3b8;
            padding: 4px 8px;
            border-radius: 0 0 8px 0;
            font-size: 11px;
            font-weight: 600;
            pointer-events: none;
            /* Let clicks pass through to the region */
            border: 1px solid rgba(255, 255, 255, 0.1);
            white-space: nowrap;
        }

        .region-label i {
            color: #3b82f6;
            /* Blue Icon */
        }

        /* Silence Region Styling */
        .wavesurfer-region[data-region-id*="silence"] {
            z-index: 1 !important;
            /* Keep silence behind speech regions */
            pointer-events: none;
        }
    </style>
</head>

<body class="p-4 md:p-8 flex flex-col items-center">

    <header class="w-full max-w-4xl flex justify-between items-center mb-8">
        <div class="flex items-center gap-3">
            <div class="w-10 h-10 bg-blue-600 rounded-xl flex items-center justify-center shadow-lg shadow-blue-500/30">
                <i class="fa-solid fa-wave-square text-white"></i>
            </div>
            <h1 class="text-2xl font-bold bg-clip-text text-transparent bg-gradient-to-r from-blue-400 to-purple-400">
                WhisperChunk
            </h1>
        </div>
        <button id="settingsBtn"
            class="p-2 hover:bg-white/10 rounded-lg transition-colors text-slate-400 hover:text-white">
            <i class="fa-solid fa-gear"></i>
        </button>
    </header>

    <div id="apiKeyModal"
        class="fixed inset-0 z-50 flex items-center justify-center bg-black/80 backdrop-blur-sm hidden">
        <div class="glass-panel w-full max-w-md p-6 rounded-2xl m-4 transform transition-all scale-100">
            <h2 class="text-xl font-bold mb-4 flex items-center gap-2">
                <i class="fa-solid fa-sliders text-yellow-500"></i> API Settings
            </h2>

            <div class="space-y-4">
                <div>
                    <label class="block text-xs text-slate-400 uppercase font-bold mb-1">API Base URL</label>
                    <input type="text" id="apiBaseUrlInput" placeholder="https://api.openai.com/v1"
                        class="w-full bg-slate-800 border border-slate-600 rounded-lg px-4 py-3 text-white focus:outline-none focus:border-blue-500 transition-colors">
                </div>

                <div>
                    <label class="block text-xs text-slate-400 uppercase font-bold mb-1">API Key</label>
                    <input type="password" id="apiKeyInput" placeholder="sk-..."
                        class="w-full bg-slate-800 border border-slate-600 rounded-lg px-4 py-3 text-white focus:outline-none focus:border-blue-500 transition-colors">
                </div>
            </div>

            <div class="flex gap-3 mt-6">
                <button onclick="clearAllCache()"
                    class="flex-1 bg-slate-700 hover:bg-red-900/50 text-slate-300 hover:text-red-200 font-semibold py-3 rounded-lg transition-all border border-transparent hover:border-red-500/30">
                    Clear Cache
                </button>
                <button onclick="saveSettings()"
                    class="flex-[2] bg-blue-600 hover:bg-blue-500 text-white font-semibold py-3 rounded-lg shadow-lg shadow-blue-500/30 transition-all">
                    Save & Continue
                </button>
            </div>
            <p class="text-xs text-slate-500 mt-4 text-center">Settings & Cache are saved locally.</p>
        </div>
    </div>

    <main class="w-full max-w-6xl grid grid-cols-1 lg:grid-cols-2 gap-6">

        <div class="flex flex-col gap-6">

            <div class="glass-panel rounded-3xl p-1 relative overflow-hidden group">
                <div
                    class="absolute inset-0 bg-gradient-to-br from-blue-500/10 to-purple-500/10 opacity-0 group-hover:opacity-100 transition-opacity">
                </div>

                <div id="dropZone"
                    class="relative border-2 border-dashed border-slate-600 hover:border-blue-500 rounded-2xl p-8 flex flex-col items-center justify-center text-center transition-all cursor-pointer h-72">
                    <input type="file" id="fileInput" class="hidden" accept=".mp3,.wav,.m4a,.ogg,.webm,.mp4">

                    <div id="dropZoneDefault" class="flex flex-col items-center gap-4">
                        <div class="w-16 h-16 bg-slate-800 rounded-full flex items-center justify-center mb-2">
                            <i class="fa-solid fa-cloud-arrow-up text-2xl text-slate-400"></i>
                        </div>
                        <div>
                            <p class="text-lg font-medium text-white">Click or Drag Audio Here</p>
                            <p class="text-sm text-slate-400 mt-1">MP3, WAV, M4A</p>
                        </div>

                        <div class="mt-4 pt-4 border-t border-slate-700 w-full flex justify-center">
                            <button onclick="loadDemo(event)"
                                class="bg-indigo-600/30 hover:bg-indigo-500/50 border border-indigo-500/50 text-indigo-300 text-sm px-4 py-2 rounded-lg transition-all flex items-center gap-2">
                                <i class="fa-solid fa-bolt"></i> Load Sample Demo
                            </button>
                        </div>
                    </div>

                    <div id="dropZoneFile" class="hidden flex-col items-center gap-4">
                        <div class="w-16 h-16 bg-blue-500/20 rounded-full flex items-center justify-center mb-2">
                            <i class="fa-solid fa-music text-2xl text-blue-400"></i>
                        </div>
                        <div>
                            <p id="fileNameDisplay" class="text-lg font-medium text-white truncate max-w-[200px]">
                                filename.mp3</p>
                            <p id="fileSizeDisplay" class="text-sm text-slate-400 mt-1">4.2 MB</p>
                        </div>
                        <button onclick="clearFile(event)"
                            class="text-xs bg-slate-700 hover:bg-slate-600 px-3 py-1 rounded-full text-white transition-colors">
                            Change File
                        </button>
                    </div>
                </div>
            </div>

            <div class="flex items-center gap-4 opacity-50">
                <div class="h-px bg-slate-600 flex-1"></div>
                <span class="text-sm font-medium">OR</span>
                <div class="h-px bg-slate-600 flex-1"></div>
            </div>

            <div class="glass-panel rounded-2xl p-6 flex items-center justify-between gap-4">
                <div class="flex items-center gap-4">
                    <button id="recordBtn"
                        class="w-12 h-12 rounded-full bg-red-500/20 hover:bg-red-500/30 text-red-500 flex items-center justify-center transition-all border border-red-500/50">
                        <i class="fa-solid fa-microphone text-xl"></i>
                    </button>
                    <div>
                        <p class="font-medium">Record Voice</p>
                        <p id="recordTimer" class="text-sm text-slate-400 font-mono">00:00</p>
                    </div>
                </div>
                <canvas id="visualizer" class="h-10 w-24 opacity-50 hidden"></canvas>
            </div>

            <button id="processBtn" disabled
                class="w-full bg-gradient-to-r from-blue-600 to-indigo-600 hover:from-blue-500 hover:to-indigo-500 disabled:opacity-50 disabled:cursor-not-allowed text-white text-lg font-bold py-4 rounded-xl shadow-lg shadow-blue-900/20 transition-all transform active:scale-95 flex items-center justify-center gap-2">
                <span>Start Smart Processing</span>
                <i class="fa-solid fa-arrow-right"></i>
            </button>

            <div id="cacheNotice"
                class="hidden text-center text-xs text-green-400 bg-green-900/20 py-2 rounded-lg border border-green-900/50">
                <i class="fa-solid fa-rotate-right mr-1"></i> Resumable session detected
            </div>

        </div>

        <div class="flex flex-col gap-6 h-full min-h-[500px]">

            <div class="flex gap-2 p-1 bg-slate-800/50 rounded-xl w-fit self-start sm:self-auto">
                <button onclick="switchTab('logs')" id="tab-logs"
                    class="px-4 py-2 rounded-lg text-sm font-medium bg-slate-700 text-white shadow-sm transition-all">Process
                    Logs</button>
                <button onclick="switchTab('result')" id="tab-result"
                    class="px-4 py-2 rounded-lg text-sm font-medium text-slate-400 hover:text-white transition-all">Transcription</button>
            </div>

            <div id="panel-logs" class="glass-panel rounded-2xl flex-1 p-6 relative overflow-hidden flex flex-col">
                <div class="absolute top-0 left-0 w-full h-1 bg-gradient-to-r from-blue-500 to-purple-500 hidden"
                    id="globalProgressLine"></div>

                <h3 class="text-sm font-semibold text-slate-400 uppercase tracking-wider mb-4">Operations Log</h3>

                <div id="logContainer" class="flex-1 overflow-y-auto pr-2 space-y-0 relative">
                    <div class="text-center mt-20 text-slate-600">
                        <i class="fa-solid fa-terminal text-4xl mb-3 opacity-30"></i>
                        <p>Waiting for input...</p>
                    </div>
                </div>
            </div>

            <div id="panel-result" class="glass-panel rounded-2xl flex-1 hidden flex-col relative h-[600px]">
                <div
                    class="p-4 border-b border-white/10 bg-slate-900/90 backdrop-blur-md z-10 shrink-0 m-2 rounded-2xl">
                    <div id="waveform" class="w-full mb-4 opacity-80 hover:opacity-100 transition-opacity"></div>

                    <div class="flex justify-between items-center">
                        <div class="flex items-center gap-3">
                            <button onclick="togglePlay()" id="playPauseBtn"
                                class="w-10 h-10 bg-blue-600 hover:bg-blue-500 rounded-full text-white flex items-center justify-center transition-all shadow-lg shadow-blue-500/30">
                                <i class="fa-solid fa-play"></i>
                            </button>
                            <span id="currentTime" class="text-xs font-mono text-blue-400">00:00</span>
                        </div>

                        <div class="flex gap-2">
                            <button onclick="copyText()"
                                class="p-2 hover:bg-white/10 rounded-lg text-slate-400 hover:text-white transition-colors"
                                title="Copy Text">
                                <i class="fa-regular fa-copy"></i>
                            </button>
                            <button onclick="downloadText()"
                                class="p-2 hover:bg-white/10 rounded-lg text-slate-400 hover:text-white transition-colors"
                                title="Download">
                                <i class="fa-solid fa-download"></i>
                            </button>
                        </div>
                    </div>
                </div>

                <div id="transcriptionOutput" class="flex-1 overflow-y-auto p-6 scroll-smooth space-y-2 max-h-[500px]">
                </div>
            </div>

        </div>

    </main>


    <script>

        // --- State Management ---
        const DEFAULT_BASE_URL = "https://api.openai.com/v1";
        const DEFAULT_API_KEY = "";

        let DEMO_CACHE_DATA = {};

        fetch('./demo_data.json')
            .then(res => res.json())
            .then(data => DEMO_CACHE_DATA = data);

        let state = {
            apiKey: localStorage.getItem('openai_api_key') || DEFAULT_API_KEY,
            baseUrl: localStorage.getItem('openai_base_url') || DEFAULT_BASE_URL,
            file: null,
            isRecording: false,
            mediaRecorder: null,
            audioChunks: [],
            isProcessing: false,
            isUserHovering: false,
            logs: [],
            wavesurfer: null,
            wsRegions: null,
            segments: [],
            // NEW: Persistence storage
            speakerRegistry: {} // Maps "Speaker A" -> "data:audio/wav;base64,..."
        };

        const elements = {
            dropZone: document.getElementById('dropZone'),
            fileInput: document.getElementById('fileInput'),
            dropZoneDefault: document.getElementById('dropZoneDefault'),
            dropZoneFile: document.getElementById('dropZoneFile'),
            fileName: document.getElementById('fileNameDisplay'),
            fileSize: document.getElementById('fileSizeDisplay'),
            processBtn: document.getElementById('processBtn'),
            recordBtn: document.getElementById('recordBtn'),
            recordTimer: document.getElementById('recordTimer'),
            visualizer: document.getElementById('visualizer'),
            logContainer: document.getElementById('logContainer'),
            transcriptionOutput: document.getElementById('transcriptionOutput'),
            globalProgress: document.getElementById('globalProgressLine'),
            apiKeyModal: document.getElementById('apiKeyModal'),
            apiKeyInput: document.getElementById('apiKeyInput'),
            apiBaseUrlInput: document.getElementById('apiBaseUrlInput'),
            cacheNotice: document.getElementById('cacheNotice')
        };

        // --- Init ---
        elements.apiKeyInput.value = state.apiKey;
        elements.apiBaseUrlInput.value = state.baseUrl;

        if (!state.apiKey) elements.apiKeyModal.classList.remove('hidden');

        document.getElementById('settingsBtn').addEventListener('click', () => {
            elements.apiKeyInput.value = state.apiKey;
            elements.apiBaseUrlInput.value = state.baseUrl;
            elements.apiKeyModal.classList.remove('hidden');
        });

        function saveSettings() {
            const key = elements.apiKeyInput.value.trim();
            const url = elements.apiBaseUrlInput.value.trim().replace(/\/+$/, "");
            if (key) { state.apiKey = key; localStorage.setItem('openai_api_key', key); }
            if (url) { state.baseUrl = url; localStorage.setItem('openai_base_url', url); }
            elements.apiKeyModal.classList.add('hidden');
        }

        function clearAllCache() {
            if (confirm('Clear cache?')) {
                Object.keys(localStorage).forEach(key => {
                    if (key.startsWith('whisper_work_')) localStorage.removeItem(key);
                });
                alert('Cache cleared.');
            }
        }

        // --- File Handling ---
        elements.dropZone.addEventListener('click', (e) => {
            if (e.target.tagName !== 'BUTTON' && e.target.parentElement.tagName !== 'BUTTON') {
                elements.fileInput.click();
            }
        });

        elements.dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            elements.dropZone.classList.add('border-blue-500', 'bg-slate-800/50');
        });

        elements.dropZone.addEventListener('dragleave', (e) => {
            e.preventDefault();
            elements.dropZone.classList.remove('border-blue-500', 'bg-slate-800/50');
        });

        elements.dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            elements.dropZone.classList.remove('border-blue-500', 'bg-slate-800/50');
            handleFile(e.dataTransfer.files[0]);
        });

        elements.fileInput.addEventListener('change', (e) => handleFile(e.target.files[0]));

        function handleFile(file) {
            if (!file) return;
            state.file = file;
            elements.fileName.innerText = file.name;
            elements.fileSize.innerText = formatBytes(file.size);
            elements.dropZoneDefault.classList.add('hidden');
            elements.dropZoneFile.classList.remove('hidden');
            elements.dropZoneFile.classList.add('flex');

            const fileId = `whisper_work_${file.name}_${file.size}`;
            if (localStorage.getItem(fileId)) {
                elements.cacheNotice.classList.remove('hidden');
            } else {
                elements.cacheNotice.classList.add('hidden');
            }

            elements.processBtn.disabled = false;
            elements.logContainer.innerHTML = '';
            addLog('System', `Loaded ${file.name} (${formatBytes(file.size)})`, 'info');
            initPlayer(file);
        }

        function clearFile(e) {
            e.stopPropagation();
            state.file = null;
            if (state.wavesurfer) { state.wavesurfer.destroy(); state.wavesurfer = null; }
            elements.fileInput.value = '';
            elements.dropZoneDefault.classList.remove('hidden');
            elements.dropZoneFile.classList.add('hidden');
            elements.dropZoneFile.classList.remove('flex');
            elements.processBtn.disabled = true;
            elements.cacheNotice.classList.add('hidden');
        }

        // --- Helper: Extract Audio for Reference ---
        // Converts a slice of audio buffer to a Base64 WAV string for the API
        function audioBufferToWavBase64(audioBuffer, startSeconds, endSeconds) {
            const sr = audioBuffer.sampleRate;
            const startOffset = Math.floor(startSeconds * sr);
            const endOffset = Math.floor(endSeconds * sr);
            const channelData = audioBuffer.getChannelData(0).slice(startOffset, endOffset);

            const wavBlob = encodeWAV(channelData, sr);

            return new Promise((resolve) => {
                const reader = new FileReader();
                reader.onloadend = () => {
                    // Reader result is "data:audio/wav;base64,..."
                    resolve(reader.result);
                };
                reader.readAsDataURL(wavBlob);
            });
        }


        // --- Processing Logic (With Persistence) ---
        elements.processBtn.addEventListener('click', async () => {
            if (!state.file || state.isProcessing) return;

            const fileId = `whisper_work_${state.file.name}_${state.file.size}`;
            let cachedWork = JSON.parse(localStorage.getItem(fileId) || '{"segments": {}, "vad": null}');

            state.isProcessing = true;
            state.segments = [];
            state.speakerRegistry = {}; // Reset speaker memory

            if (state.wsRegions) state.wsRegions.clearRegions();
            elements.transcriptionOutput.innerHTML = '';

            elements.processBtn.disabled = true;
            elements.processBtn.innerHTML = `<i class="fa-solid fa-circle-notch fa-spin"></i> Processing...`;
            elements.globalProgress.classList.remove('hidden');
            switchTab('logs');

            try {
                // 1. Decode Audio
                const logId1 = addLog('Analysis', `Decoding audio data...`, 'loading');
                const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                const arrayBuffer = await state.file.arrayBuffer();
                const audioBuffer = await audioCtx.decodeAudioData(arrayBuffer);
                updateLog(logId1, 'success', `Audio decoded (${formatBytes(state.file.size)})`);

                // 2. VAD Split
                let chunks;
                if (cachedWork.vad && cachedWork.vad.length > 0) {
                    addLog('Cache', `Restored VAD map from cache`, 'success');
                    chunks = rehydrateChunks(audioBuffer, cachedWork.vad);
                } else {
                    const logId2 = addLog('VAD Processing', `Splitting Audio (Smart VAD)...`, 'loading');
                    chunks = smartSplit(audioBuffer, 10);
                    updateLog(logId2, 'success', `Split into ${chunks.length} chunks`);
                    cachedWork.vad = chunks.map(c => ({ start: c.start, end: c.end }));
                    saveCache(fileId, cachedWork);
                }

                // 3. Process Loop
                for (let i = 0; i < chunks.length; i++) {
                    const chunkData = chunks[i];
                    const chunkId = `chunk_${i}_${chunkData.start.toFixed(3)}`;
                    let newSegments = [];

                    // Prepare Speaker References (Persistence)
                    // We convert our registry { "Speaker A": "base64..." } into parallel arrays
                    const knownNames = Object.keys(state.speakerRegistry);
                    const knownRefs = Object.values(state.speakerRegistry);

                    // --- CACHE CHECK ---
                    // Note: If you want to force re-processing to fix speakers, you might need to clear cache
                    if (cachedWork.segments && cachedWork.segments[chunkId]) {
                        addLog('Cache', `Restored Chunk ${i + 1}/${chunks.length}`, 'success');
                        newSegments = cachedWork.segments[chunkId];
                    } else {
                        // --- API CALL ---
                        const chunkFile = new File([chunkData.blob], `chunk_${i}.wav`, { type: 'audio/wav' });
                        const logId = addLog('Upload', `Transcribing Chunk ${i + 1}/${chunks.length}...`, 'loading');

                        // Pass the accumulated speaker memory
                        const result = await transcribeChunk(chunkFile, knownNames, knownRefs);
                        updateLog(logId, 'success', `Chunk ${i + 1} processed`);

                        if (result.segments) {
                            newSegments = result.segments.map(seg => ({
                                ...seg,
                                start: seg.start + chunkData.start,
                                end: seg.end + chunkData.start
                            }));
                        } else if (result.text) {
                            newSegments = [{
                                text: result.text, start: chunkData.start, end: chunkData.end, speaker: "Unknown"
                            }];
                        }

                        // Save to Cache
                        if (!cachedWork.segments) cachedWork.segments = {};
                        cachedWork.segments[chunkId] = newSegments;
                        saveCache(fileId, cachedWork);
                    }

                    // --- LEARNING PHASE (Update Registry) ---
                    // Scan the results. If we see a speaker we don't have a fingerprint for, capture them!
                    for (const seg of newSegments) {
                        const spk = seg.speaker;

                        // Only learn if we have a valid speaker name and haven't learned them yet
                        if (spk && spk !== "Unknown" && !state.speakerRegistry[spk]) {

                            // Calculate relative start/end within the chunk audio buffer
                            const relStart = Math.max(0, seg.start - chunkData.start);
                            const relEnd = Math.min(chunkData.end - chunkData.start, seg.end - chunkData.start);

                            const duration = relEnd - relStart;

                            // API CONSTRAINT: Reference audio must be between 1.2s and 10s
                            if (duration >= 1.2) {
                                // If segment is too long, just take the first 9 seconds
                                const safeEnd = (duration > 9.0) ? (seg.start + 9.0) : seg.end;

                                // Extract audio using GLOBAL timestamps (seg.start / safeEnd)
                                const base64Ref = await audioBufferToWavBase64(audioBuffer, seg.start, safeEnd);
                                state.speakerRegistry[spk] = base64Ref;
                                console.log(`ðŸ§  Learned voice signature for: ${spk} (${(safeEnd - seg.start).toFixed(2)}s)`);
                            }
                        }
                    }

                    appendTranscription(newSegments);
                }

                addLog('Success', 'Processing complete.', 'success');
                switchTab('result');

            } catch (error) {
                console.error(error);
                addLog('Error', error.message || "Error", 'error');
            } finally {
                state.isProcessing = false;
                elements.processBtn.disabled = false;
                elements.processBtn.innerHTML = `<span>Start Smart Processing</span><i class="fa-solid fa-arrow-right"></i>`;
                elements.globalProgress.classList.add('hidden');
            }
        });

        async function transcribeChunk(fileChunk, knownNames = [], knownRefs = []) {
            const formData = new FormData();
            formData.append("file", fileChunk);
            formData.append("model", "gpt-4o-transcribe-diarize"); // Ensure this is the correct model name
            formData.append("language", "fa"); // Ensure this is the correct model name
            formData.append("response_format", "diarized_json");
            formData.append("chunking_strategy", "auto");

            // Construct Extra Body for Speaker ID
            const extraBody = {};
            if (knownNames.length > 0) {
                extraBody.known_speaker_names = knownNames;
                extraBody.known_speaker_references = knownRefs;
                // We must append this as a stringified JSON field for some proxies, 
                // or as separate fields depending on the specific API gateway requirements.
                // Standard OpenAI usually takes top-level parameters, but specialized endpoints might differ.
                // Based on your python code, 'extra_body' usually merges into the JSON payload.
                // Since we are using FormData (multipart/form-data), complex JSON objects are tricky.
                // WE WILL APPEND THEM AS STRINGIFIED FIELDS mimicking the structure.
            }

            // NOTE: If your API endpoint expects strict JSON, we cannot use FormData for file upload easily in standard fetch without boundary issues.
            // However, standard OpenAI Audio API uses multipart/form-data. 
            // Parameters like 'known_speaker_names[]' might be needed.

            // Strategy: Append them as array fields if supported by your specific provider wrapper
            knownNames.forEach(name => formData.append("known_speaker_names[]", name));
            knownRefs.forEach(ref => formData.append("known_speaker_references[]", ref));

            const endpoint = `${state.baseUrl}/audio/transcriptions`;

            try {
                const response = await fetch(endpoint, {
                    method: "POST",
                    headers: { "Authorization": `Bearer ${state.apiKey}` },
                    body: formData
                });

                if (!response.ok) {
                    const errText = await response.text();
                    throw new Error(`API Error: ${errText}`);
                }

                return await response.json();
            } catch (e) {
                throw e;
            }
        }

        // --- Audio Utils ---
        function getRMS(data) {
            let sum = 0;
            for (let i = 0; i < data.length; i += 5) sum += data[i] * data[i];
            return Math.sqrt(sum / (data.length / 5));
        }

        function floatTo16BitPCM(view, offset, input) {
            for (let i = 0; i < input.length; i++, offset += 2) {
                let s = Math.max(-1, Math.min(1, input[i]));
                s = s < 0 ? s * 0x8000 : s * 0x7FFF;
                view.setInt16(offset, s, true);
            }
        }

        function writeString(view, offset, string) {
            for (let i = 0; i < string.length; i++) view.setUint8(offset + i, string.charCodeAt(i));
        }

        function encodeWAV(samples, sampleRate) {
            const buffer = new ArrayBuffer(44 + samples.length * 2);
            const view = new DataView(buffer);
            writeString(view, 0, 'RIFF');
            view.setUint32(4, 36 + samples.length * 2, true);
            writeString(view, 8, 'WAVE');
            writeString(view, 12, 'fmt ');
            view.setUint32(16, 16, true);
            view.setUint16(20, 1, true);
            view.setUint16(22, 1, true);
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, sampleRate * 2, true);
            view.setUint16(32, 2, true);
            view.setUint16(34, 16, true);
            writeString(view, 36, 'data');
            view.setUint32(40, samples.length * 2, true);
            floatTo16BitPCM(view, 44, samples);
            return new Blob([view], { type: 'audio/wav' });
        }

        function smartSplit(audioBuffer, maxDuration) {
            const sr = audioBuffer.sampleRate;
            const channelData = audioBuffer.getChannelData(0);
            const chunks = [];
            let startSample = 0;
            const maxSamples = maxDuration * sr;
            const silenceThresh = 0.015;

            while (startSample < channelData.length) {
                let endSample = Math.min(startSample + maxSamples, channelData.length);
                if (endSample < channelData.length) {
                    const scanWindow = 2.0 * sr;
                    const scanStart = Math.max(startSample + (1.0 * sr), endSample - scanWindow);
                    let bestSplit = -1;
                    let lowestRMS = 1.0;
                    const windowSize = Math.floor(0.1 * sr);
                    for (let i = endSample; i > scanStart; i -= windowSize) {
                        const windowStart = Math.max(startSample, i - windowSize);
                        const slice = channelData.slice(windowStart, i);
                        const rms = getRMS(slice);
                        if (rms < silenceThresh) { bestSplit = i; break; }
                        if (rms < lowestRMS) { lowestRMS = rms; if (rms < 0.05) bestSplit = i; }
                    }
                    if (bestSplit !== -1) endSample = bestSplit;
                }
                const chunkSamples = channelData.slice(startSample, endSample);
                const blob = encodeWAV(chunkSamples, sr);
                chunks.push({ blob, start: startSample / sr, end: endSample / sr });
                startSample = endSample;
            }
            return chunks;
        }

        function rehydrateChunks(audioBuffer, vadData) {
            const sr = audioBuffer.sampleRate;
            const channelData = audioBuffer.getChannelData(0);
            return vadData.map(v => {
                const startSample = Math.floor(v.start * sr);
                const endSample = Math.floor(v.end * sr);
                const chunkSamples = channelData.slice(startSample, endSample);
                const blob = encodeWAV(chunkSamples, sr);
                return { blob, start: v.start, end: v.end };
            });
        }

        function saveCache(fileId, data) {
            try { localStorage.setItem(fileId, JSON.stringify(data)); } catch (e) { }
        }

        // --- UI Utils ---
        function switchTab(tabName) {
            if (tabName === 'logs') {
                document.getElementById('panel-logs').classList.remove('hidden');
                document.getElementById('panel-logs').classList.add('flex');
                document.getElementById('panel-result').classList.add('hidden');
                document.getElementById('panel-result').classList.remove('flex');
                document.getElementById('tab-logs').classList.replace('text-slate-400', 'text-white');
                document.getElementById('tab-logs').classList.replace('bg-transparent', 'bg-slate-700');
                document.getElementById('tab-result').classList.replace('text-white', 'text-slate-400');
                document.getElementById('tab-result').classList.remove('bg-slate-700');
            } else {
                document.getElementById('panel-logs').classList.add('hidden');
                document.getElementById('panel-logs').classList.remove('flex');
                document.getElementById('panel-result').classList.remove('hidden');
                document.getElementById('panel-result').classList.add('flex');
                document.getElementById('tab-logs').classList.replace('text-white', 'text-slate-400');
                document.getElementById('tab-logs').classList.remove('bg-slate-700');
                document.getElementById('tab-result').classList.replace('text-slate-400', 'text-white');
                document.getElementById('tab-result').classList.add('bg-slate-700');
            }
        }

        function addLog(type, message, status) {
            const id = 'log-' + Math.random().toString(36).substr(2, 9);
            const icon = status === 'loading' ? '<i class="fa-solid fa-circle-notch fa-spin text-blue-400"></i>' :
                status === 'success' ? '<i class="fa-solid fa-check text-green-400"></i>' :
                    status === 'error' ? '<i class="fa-solid fa-triangle-exclamation text-red-400"></i>' :
                        '<i class="fa-solid fa-info-circle text-slate-400"></i>';
            const html = `
            <div id="${id}" class="step-item relative pl-10 pb-8 fade-in">
                <div class="step-line absolute left-[11px] top-8 h-full w-0.5 bg-slate-700"></div>
                <div class="absolute left-0 top-1 w-6 h-6 rounded-full bg-slate-800 border border-slate-600 flex items-center justify-center z-10 shadow-lg">${icon}</div>
                <div class="flex flex-col gap-1">
                    <span class="text-xs font-bold text-slate-500 uppercase tracking-wider">${type}</span>
                    <span class="text-sm text-slate-200">${message}</span>
                    ${status === 'loading' ? '<div class="h-1 w-full bg-slate-700 rounded-full mt-2 overflow-hidden"><div class="h-full bg-blue-500 w-1/2 animate-[shimmer_1s_infinite]"></div></div>' : ''}
                </div>
            </div>`;
            elements.logContainer.insertAdjacentHTML('beforeend', html);
            elements.logContainer.scrollTop = elements.logContainer.scrollHeight;
            return id;
        }

        function updateLog(id, status, newMessage) {
            const el = document.getElementById(id);
            if (!el) return;
            const iconContainer = el.querySelector('.w-6');
            const messageEl = el.querySelectorAll('span')[1];
            if (status === 'success') {
                iconContainer.innerHTML = '<i class="fa-solid fa-check text-green-400"></i>';
                iconContainer.classList.add('border-green-500/50');
            } else if (status === 'error') {
                iconContainer.innerHTML = '<i class="fa-solid fa-xmark text-red-400"></i>';
                iconContainer.classList.add('border-red-500/50');
            }
            if (newMessage) messageEl.innerText = newMessage;
            const pBar = el.querySelector('.h-1');
            if (pBar) pBar.remove();
        }

        function formatBytes(bytes, decimals = 2) {
            if (!+bytes) return '0 Bytes';
            const k = 1024;
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return `${parseFloat((bytes / Math.pow(k, i)).toFixed(decimals))} ${['Bytes', 'KB', 'MB', 'GB'][i]}`;
        }

        // --- Visuals & Transcription Display ---
        elements.transcriptionOutput.addEventListener('mouseenter', () => state.isUserHovering = true);
        elements.transcriptionOutput.addEventListener('mouseleave', () => state.isUserHovering = false);

        function appendTranscription(segments) {
            const container = elements.transcriptionOutput;
            segments.forEach(seg => {
                state.segments.push(seg);
                const segIndex = state.segments.length - 1;


                // 1. Rename Logic
                let displaySpeaker = seg.speaker;
                if (seg.speaker === "A") displaySpeaker = "Mostafa";
                if (seg.speaker === "B") displaySpeaker = "Mamti";

                // 2. Color & Icon Logic
                // Mostafa = Blue Tie, Mamti = Pink User
                const isMamti = displaySpeaker === "Mamti";
                const iconClass = isMamti ? "fa-user text-pink-400" : "fa-user-tie text-blue-400";

                // Update the badge styles to match
                const badgeColor = isMamti
                    ? "bg-pink-600/30 text-pink-300 border-pink-500/30"
                    : "bg-blue-600/30 text-blue-300 border-blue-500/30";

                // --- UPDATE HTML GENERATION BELOW ---


                // const speakerName = seg.speaker || 'Speaker';
                // const isAlternate = /2|B|Agent|Interviewer/i.test(speakerName);
                // const iconClass = isAlternate ? 'fa-user-tie' : 'fa-user';

                const labelEl = document.createElement('div');
                labelEl.className = 'region-label'; 
                // labelEl.innerHTML = `<i class="fa-solid ${iconClass}"></i><span>${speakerName}</span>`;

                // In labelEl.innerHTML:
                labelEl.innerHTML = `<i class="fa-solid ${iconClass}"></i><span>${displaySpeaker}</span>`;

                // In speakerBadge generation:
                const speakerBadge = seg.speaker
                    ? `<span class="${badgeColor} px-1.5 py-0.5 rounded ml-2 uppercase tracking-wide font-bold text-[10px] border">
                <i class="fa-solid ${iconClass} mr-1 text-[9px]"></i>${displaySpeaker}
               </span>` : '';



                if (state.wsRegions) {
                    state.wsRegions.addRegion({
                        id: `region-${segIndex}`, start: seg.start, end: seg.end,
                        content: labelEl, color: 'rgba(59, 130, 246, 0.1)', drag: false, resize: false
                    });
                }

                const startTime = formatTime(seg.start);
                const endTime = formatTime(seg.end);
                // const speakerBadge = seg.speaker ? `<span class="bg-indigo-600/30 text-indigo-300 px-1.5 py-0.5 rounded ml-2 uppercase tracking-wide font-bold text-[10px] border border-indigo-500/30"><i class="fa-solid ${iconClass} mr-1 text-[9px]"></i>${seg.speaker}</span>` : '';

                const div = document.createElement('div');
                div.id = `seg-${segIndex}`;
                div.onclick = () => playSegment(seg.start);
                div.className = "mb-2 p-3 rounded-lg transition-all border-l-4 border-transparent hover:bg-white/5 cursor-pointer group hover:border-blue-500";
                div.innerHTML = `
                <div class="flex items-center gap-2 text-xs text-slate-500 mb-1 font-mono">
                    <span class="bg-slate-800 px-1.5 py-0.5 rounded text-blue-400 border border-slate-700">${startTime}</span>
                    <i class="fa-solid fa-arrow-right text-[10px] opacity-30"></i>
                    <span class="bg-slate-800 px-1.5 py-0.5 rounded text-blue-400 border border-slate-700">${endTime}</span>
                    ${speakerBadge}
                </div>
                <p class="text-slate-200 leading-relaxed group-hover:text-white transition-colors text-[15px]" dir="auto">${seg.text}</p>`;
                container.appendChild(div);
            });
            container.scrollTop = container.scrollHeight;
        }

        function initPlayer(file) {
            if (state.wavesurfer) state.wavesurfer.destroy();
            const container = document.getElementById('waveform');
            container.innerHTML = '';
            state.wsRegions = window.RegionsPlugin ? RegionsPlugin.create() : null;

            const wsOptions = {
                container: container, waveColor: '#475569', progressColor: '#3b82f6', cursorColor: '#60a5fa',
                barWidth: 2, barGap: 1, barRadius: 2, height: 64, plugins: state.wsRegions ? [state.wsRegions] : []
            };
            state.wavesurfer = WaveSurfer.create(wsOptions);
            state.wavesurfer.loadBlob(file);

            state.wavesurfer.on('ready', () => { highlightSilence(); });
            state.wavesurfer.on('audioprocess', (time) => {
                document.getElementById('currentTime').innerText = formatTime(time);
                highlightActiveSegment(time);
            });
            state.wavesurfer.on('finish', () => document.getElementById('playPauseBtn').innerHTML = '<i class="fa-solid fa-play"></i>');
            state.wavesurfer.on('play', () => document.getElementById('playPauseBtn').innerHTML = '<i class="fa-solid fa-pause"></i>');
            state.wavesurfer.on('pause', () => document.getElementById('playPauseBtn').innerHTML = '<i class="fa-solid fa-play"></i>');
        }

        function togglePlay() { if (state.wavesurfer) state.wavesurfer.playPause(); }
        function playSegment(startTime) { if (state.wavesurfer) { state.wavesurfer.setTime(startTime); state.wavesurfer.play(); } }

        function highlightActiveSegment(time) {
            const activeIdx = state.segments.findIndex(s => time >= s.start && time <= s.end);
            document.querySelectorAll('.active-segment').forEach(el => el.classList.remove('active-segment'));
            if (activeIdx !== -1) {
                const el = document.getElementById(`seg-${activeIdx}`);
                if (el) {
                    el.classList.add('active-segment');
                    if (!state.isUserHovering) el.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }
            }
        }

        function highlightSilence() {
            if (!state.wavesurfer || !state.wsRegions) return;
            const decodedData = state.wavesurfer.getDecodedData();
            if (!decodedData) return;
            const rawData = decodedData.getChannelData(0);
            const sr = decodedData.sampleRate;
            const silenceThreshold = 0.01, minSilenceDuration = 0.5, step = 1024;
            let isSilent = false, silenceStart = 0;

            for (let i = 0; i < rawData.length; i += step) {
                let sum = 0;
                for (let j = 0; j < step && (i + j) < rawData.length; j++) sum += rawData[i + j] * rawData[i + j];
                const rms = Math.sqrt(sum / (step));

                if (rms < silenceThreshold) {
                    if (!isSilent) { isSilent = true; silenceStart = i / sr; }
                } else {
                    if (isSilent) {
                        isSilent = false;
                        if ((i / sr) - silenceStart > minSilenceDuration) {
                            state.wsRegions.addRegion({
                                id: `silence-${Math.random()}`, start: silenceStart, end: i / sr,
                                color: 'rgba(239, 68, 68, 0.3)', drag: false, resize: false, content: ''
                            });
                        }
                    }
                }
            }
            addLog('Analysis', `Silence analysis complete`, 'info');
        }

        function formatTime(seconds) {
            const pad = (num) => num.toString().padStart(2, '0');
            const h = Math.floor(seconds / 3600), m = Math.floor((seconds % 3600) / 60), s = Math.floor(seconds % 60), ms = Math.floor((seconds % 1) * 10);
            return h > 0 ? `${pad(h)}:${pad(m)}:${pad(s)}.${ms}` : `${pad(m)}:${pad(s)}.${ms}`;
        }


        // Demo & Copy/Download
        async function loadDemo(event) {
            event.stopPropagation();
            try {
                const response = await fetch('https://raw.githubusercontent.com/mmshooreshi/nemo/refs/heads/main/demo.mp3');
                if (!response.ok) throw new Error("Demo file missing.");
                const blob = await response.blob();
                const file = new File([blob], "demo.mp3", { type: "audio/mpeg" });

                // Hardcoded cache for demo
                const cacheKey = `whisper_work_${file.name}_${file.size}`;
                localStorage.setItem(cacheKey, JSON.stringify(DEMO_CACHE_DATA));

                handleFile(file);
            } catch (e) { alert("Demo load failed: " + e.message); }
        }
        function copyText() { navigator.clipboard.writeText(elements.transcriptionOutput.innerText); alert('Copied!'); }
        function downloadText() {
            const blob = new Blob([elements.transcriptionOutput.innerText], { type: 'text/plain' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a'); a.href = url; a.download = `transcription.txt`; a.click();
        }

        // --- Recorder Visualizer ---
        function startRecording() {
            navigator.mediaDevices.getUserMedia({ audio: true }).then(stream => {
                state.mediaRecorder = new MediaRecorder(stream);
                state.audioChunks = [];
                state.mediaRecorder.ondataavailable = e => state.audioChunks.push(e.data);
                state.mediaRecorder.onstop = () => {
                    const blob = new Blob(state.audioChunks, { type: 'audio/wav' });
                    handleFile(new File([blob], `rec_${Date.now()}.wav`, { type: 'audio/wav' }));
                    stream.getTracks().forEach(t => t.stop());
                };
                state.mediaRecorder.start();
                state.isRecording = true;
                elements.recordBtn.classList.add('recording-pulse', 'bg-red-500', 'text-white');
                elements.visualizer.classList.remove('hidden');
                startTimer();

                // Visualizer logic
                const ac = new AudioContext(), src = ac.createMediaStreamSource(stream), anl = ac.createAnalyser();
                src.connect(anl); anl.fftSize = 64;
                const da = new Uint8Array(anl.frequencyBinCount), cvs = elements.visualizer, ctx = cvs.getContext("2d");
                function draw() {
                    if (!state.isRecording) return;
                    requestAnimationFrame(draw); anl.getByteFrequencyData(da);
                    ctx.clearRect(0, 0, cvs.width, cvs.height);
                    for (let i = 0; i < da.length; i++) {
                        const h = da[i] / 2;
                        ctx.fillStyle = `rgb(${h + 100},50,50)`;
                        ctx.fillRect(i * 3, cvs.height - h, 2, h);
                    }
                }
                draw();
            }).catch(err => alert("Mic Error: " + err));
        }
        function stopRecording() { state.mediaRecorder.stop(); state.isRecording = false; elements.recordBtn.classList.remove('recording-pulse', 'bg-red-500', 'text-white'); stopTimer(); elements.visualizer.classList.add('hidden'); }
        let tmr; function startTimer() { let s = 0; elements.recordTimer.innerText = "00:00"; tmr = setInterval(() => { s++; elements.recordTimer.innerText = `${Math.floor(s / 60).toString().padStart(2, '0')}:${(s % 60).toString().padStart(2, '0')}`; }, 1000); }
        function stopTimer() { clearInterval(tmr); }
    </script>

</body>

</html>